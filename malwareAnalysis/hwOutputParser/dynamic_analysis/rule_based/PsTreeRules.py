import re
from typing_extensions import override
from typing import Optional

from malwareAnalysis.hwOutputParser.dynamic_analysis.rule_based.AbstractRules import AbstractRules
from malwareAnalysis.malwareAnalysisTool.analysis.models.data.PsTreeData import PsTreeData


class PsTreeRules(AbstractRules[PsTreeData]):

    legitimate_processes: dict[str, str] = {
        "system": "C:\\Windows\\System32\\",
        "smss.exe": "C:\\Windows\\System32\\",
        "csrss.exe": "C:\\Windows\\System32\\",
        "wininit.exe": "C:\\Windows\\System32\\",
        "services.exe": "C:\\Windows\\System32\\",
        "lsass.exe": "C:\\Windows\\System32\\",
        "svchost.exe": "C:\\Windows\\System32\\",
        "winlogon.exe": "C:\\Windows\\System32\\",
        "explorer.exe": "C:\\Windows\\",
        "taskmgr.exe": "C:\\Windows\\System32\\",
        "spoolsv.exe": "C:\\Windows\\System32\\",
        "msmpeng.exe": "C:\\Program Files\\Windows Defender\\",
        "wuauclt.exe": "C:\\Windows\\System32\\",
        "trustedinstaller.exe": "C:\\Windows\\servicing\\",
        "notepad.exe": "C:\\Windows\\System32\\",
        "cmd.exe": "C:\\Windows\\System32\\",
        "powershell.exe": "C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\",
        "rundll32.exe": "C:\\Windows\\System32\\",
        "mshta.exe": "C:\\Windows\\System32\\",
        "wscript.exe": "C:\\Windows\\System32\\",
        "cscript.exe": "C:\\Windows\\System32\\"
    }

    # List of processes commonly misused for malicious purposes
    suspicious_processes_names: list[str] = [
        "svchost.exe",
        "powershell.exe",
        "cmd.exe",
        "rundll32.exe",
        "mshta.exe",
        "wscript.exe",
        "cscript.exe"
    ]

    unusual_processes: list[PsTreeData] = []

    @override
    def find_unusual_processes(self) -> None:

        def filter_entries(data: list[PsTreeData], parent_is_new: bool = False) -> None:
            for process in data:
                is_legit: bool = self.is_legitimate_process(process.ImageFileName, process.Path)
                if not is_legit and process not in self.unusual_processes:
                    self.unusual_processes.append(process)

                filter_entries(process.children, parent_is_new)

        filter_entries(self.analyzer_output)

    def is_legitimate_process(self, process_name: str, process_path: Optional[str]) -> bool:
        """
        Checks whether a given process is legitimate based on its name and path.
        """
        expected_path: Optional[str] = self.legitimate_processes.get(process_name.lower())

        if process_path is None:
            return False  # No process path available, thus considered non-legitimate

        if process_name.lower() in self.suspicious_processes_names:
            # Additional check for suspicious processes
            if not expected_path or not process_path.lower().startswith(expected_path.lower()):
                return False  # Mark as potentially dangerous
            else:
                return True  # Legitimate process in expected path
        else:
            # Standard check for other processes
            return bool(expected_path and process_path.lower().startswith(expected_path.lower()))