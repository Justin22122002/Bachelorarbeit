from typing import Optional
import pyshark
from dataclasses import dataclass

from malwareAnalysis.hwOutputParser.pcap.PacketInfo import PacketInfo


@dataclass
class PcapAnalyzer:
    """
    Class to analyze PCAP files and extract packet information.
    """
    file_path: str
    packets: list[PacketInfo] = None
    missed_bytes: Optional[int] = None

    def __post_init__(self):
        self.packets = []
        self.missed_bytes = None

    def analyze(self) -> None:
        """
        Parses the PCAP file and populates the packets list with PacketInfo instances.
        """
        try:
            capture = pyshark.FileCapture(self.file_path, keep_packets=False, include_raw=True, use_json=True)
            for packet in capture:
                try:
                    source_ip = packet.ip.src if hasattr(packet, 'ip') else None
                    destination_ip = packet.ip.dst if hasattr(packet, 'ip') else None
                    source_port = packet[packet.transport_layer].srcport if hasattr(packet, 'transport_layer') else None
                    destination_port = packet[packet.transport_layer].dstport if hasattr(packet, 'transport_layer') else None
                    protocol = packet.highest_layer if hasattr(packet, 'highest_layer') else None
                    service = self.detect_service(packet)
                    duration = float(packet.frame_info.time_delta) if hasattr(packet.frame_info, 'time_delta') else None
                    length = int(packet.length) if hasattr(packet, 'length') else None

                    # Extracting bytes sent from origin and destination
                    orig_bytes = int(packet.tcp.len) if hasattr(packet, 'tcp') and hasattr(packet.tcp, 'len') else None
                    resp_bytes = int(packet.udp.length) if hasattr(packet, 'udp') and hasattr(packet.udp, 'length') else None

                    # Extracting connection state
                    conn_state = packet.tcp.flags_str if hasattr(packet, 'tcp') and hasattr(packet.tcp, 'flags_str') else None

                    # Extracting missed bytes from capture stats (if available)
                    missed_bytes = int(packet.frame_info.missed_bytes) if hasattr(packet.frame_info, 'missed_bytes') and packet.frame_info.missed_bytes else None

                    new_packet = PacketInfo(
                        origin_ip=source_ip,
                        destination_ip=destination_ip,
                        origin_port=source_port,
                        destination_port=destination_port,
                        protocol=protocol,
                        service=service,
                        duration=duration,
                        orig_bytes=orig_bytes,
                        resp_bytes=resp_bytes,
                        conn_state=conn_state,
                        missed_bytes=missed_bytes,
                        length=length
                    )

                    print(new_packet)
                    self.packets.append(new_packet)
                except AttributeError:
                    # Skip packets missing attributes
                    continue
            capture.close()
        except Exception as e:
            print(f"Error processing PCAP file: {e}")

    @staticmethod
    def detect_service(packet) -> Optional[str]:
        """
        Detects the service based on the packet's layers.
        """
        service_layers = ['http', 'dns', 'ftp', 'smtp', 'ssh', 'telnet']
        for layer in service_layers:
            if hasattr(packet, layer):
                return layer  # Return the detected service
        return None

    def get_packets(self) -> list[PacketInfo]:
        """
        Returns the list of PacketInfo objects after analysis.
        """
        return self.packets


def main() -> None:
    """
    Main function to initialize and run the PCAP analysis.
    """
    file_path: str = 'E:/data_sandbox/1fcbe5d51360bee55f55c791a95df8c61f73e117bda89b9439d74df5cee7aa71_benign/traffic_report/network_traffic.pcap'
    analyzer: PcapAnalyzer = PcapAnalyzer(file_path)
    analyzer.analyze()
    for packet in analyzer.get_packets():
        print(packet)


if __name__ == "__main__":
    main()