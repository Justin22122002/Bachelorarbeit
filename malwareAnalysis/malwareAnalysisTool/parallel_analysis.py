import os
import sys
from concurrent.futures import ThreadPoolExecutor, as_completed
from threading import Lock

from malwareAnalysis.malwareAnalysisTool.csv.CsvAnalysisHandler import CsvAnalysisHandler
from malwareAnalysis.malwareAnalysisTool.analysis.StrategyFactory import StrategyFactory
from malwareAnalysis.malwareAnalysisTool.analysis.models.OperatingSystem import OperatingSystem
from malwareAnalysis.malwareAnalysisTool.analysis.Analyzer import Analyzer
from malwareAnalysis.malwareAnalysisTool.analysis.AnalyzerOptions import AnalyzerOptions
from malwareAnalysis.malwareAnalysisTool.dir_scanner.main import get_directories_with_suffix_map


def title() -> None:
    """Prints the title banner."""
    print(r"""
--------------------------------------------------------------------------------------------
    ___  ___      _                           ______                                 
    |  \/  |     | |                         / ____|                                 
    | \  / | __ _| |_      ____ _ _ __ ___  | (___   ___ __ _ _ __  _ __   ___ _ __ 
    | |\/| |/ _` | \ \ /\ / / _` | '__/ _ \  \___ \ / __/ _` | '_ \| '_ \ / _ \ '__|
    | |  | | (_| | |\ V  V / (_| | | |  __/  ____) | (_| (_| | | | | | | |  __/ |   
    |_|  |_|\__,_|_| \_/\_/ \__,_|_|  \___| |_____/ \___\__,_|_| |_|_| |_|\___|_|   

--------------------------------------------------------------------------------------------                                                                               
Code by: Justin Groh
NOTE: Absolute path to memory image should be given as command-line argument.
--------------------------------------------------------------------------------------------
    """)


def create_analyzer_options(input_path: str, output_path: str) -> AnalyzerOptions:
    """Creates and returns an AnalyzerOptions object."""
    return AnalyzerOptions(
        input_path=input_path,
        volatility3_path="../volatility3/vol.py",
        output_file_path="",
        output_dir_path=output_path,
        operating_system=OperatingSystem.WINDOWS,
    )


def get_input_path(input_path: str = None) -> str:
    """Returns the memory image path from the command line or a default value."""
    if input_path is None:
        try:
            input_path: str = sys.argv[1]
        except IndexError:
            print("\033[1;31mGive absolute path to the memory image as command-line argument.\033[0m")
            exit()
    else:
        print(f"The given memory image file path is: - \033[1;32m{input_path}\033[0m\n")
    return input_path


def check_file_exists(file_path: str) -> bool:
    """Checks if a file exists at the given path."""
    if os.path.isfile(file_path):
        print(f"\033[1;32mFile exists: {file_path}\033[0m")
        return True
    else:
        print(f"\033[1;31mFile not found: {file_path}\033[0m")
        return False


def analyze_dump(input_path: str, output_csv: str, base_dir: str, is_header_written_lock: Lock, csv_lock: Lock, is_header_written: list) -> None:
    """Runs the memory dump analysis process."""
    if not check_file_exists(input_path):
        print(f"Skipping analysis for {input_path} as the file does not exist.")
        return

    options: AnalyzerOptions = create_analyzer_options(input_path, "./data" + input_path.replace(base_dir, ""))
    strategies = StrategyFactory.create_strategies(options)
    analyzer: Analyzer = Analyzer(strategies)
    analyzer.analyze_memory_dump()
    analyzer.analyze_output()
    summaries = analyzer.get_analyzer_summary()

    with csv_lock:
        csv_handler = CsvAnalysisHandler(output_csv, input_path)
        if not is_header_written[0]:
            with is_header_written_lock:
                if not is_header_written[0]:
                    csv_handler.write_header(summaries)
                    is_header_written[0] = True
        csv_handler.append_data(summaries)

    print(f"Processed {input_path}")


def main() -> None:
    """Main function to execute the memory analysis process."""
    title()

    memory_dump_dir_name: str = "raw"
    memory_dump_name: list[str] = ["raw_0.bin", "raw_1.bin", "raw_2.bin"]
    base_dir: str = "F:\\Run_1"
    suffixes: list[str] = ["_spyware", "_ransomware", "_trojan", "_benign"]
    matching_dirs_map: dict[str, list[str]] = get_directories_with_suffix_map(base_dir, suffixes)

    output_csv: str = "output_file_Run_1.csv"
    is_header_written: list[bool] = [False]
    is_header_written_lock: Lock = Lock()
    csv_lock: Lock = Lock()
    tasks: list = []

    with ThreadPoolExecutor(max_workers=10) as executor:
        for suffix, directories in matching_dirs_map.items():
            print(f"\nSuffix '{suffix}':")
            for dir_path in directories:
                for dump_name in memory_dump_name:
                    input_path: str = f"{dir_path}/{memory_dump_dir_name}/{dump_name}"
                    input_path = get_input_path(input_path)

                    tasks.append(
                        executor.submit(
                            analyze_dump,
                            input_path,
                            output_csv,
                            base_dir,
                            is_header_written_lock,
                            csv_lock,
                            is_header_written
                        )
                    )

        # Optional: Monitor progress
        for future in as_completed(tasks):
            try:
                future.result()
            except Exception as e:
                print(f"Error occurred: {e}")

    print("\033[1;32mAll analyses completed.\033[0m")


if __name__ == "__main__":
    main()
