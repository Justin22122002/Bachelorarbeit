from abc import ABC, abstractmethod
import os
import subprocess
from typing import TypeVar, Generic

from malwareAnalysis.malwareAnalysisTool.analysis.AnalyzerOptions import AnalyzerOptions
from malwareAnalysis.malwareAnalysisTool.analysis.models.OperatingSystem import OperatingSystem
from malwareAnalysis.malwareAnalysisTool.analysis.models.result.Summary import Summary

T = TypeVar('T')
R = TypeVar('R', bound=Summary)

class AnalysisStrategy(ABC, Generic[T, R]):
    def __init__(self, analyzer_options: AnalyzerOptions) -> None:
        self.analyzer_options: AnalyzerOptions = analyzer_options
        self.analyzer_output: list[T] = []
        self.analyzer_summary: R | None = None

    @abstractmethod
    def get_command(self) -> dict[OperatingSystem, str]:
        """Each concrete strategy should return its specific Volatility command."""
        pass

    @abstractmethod
    def analyze_output(self, file_path: str | None = None) -> None:
        """Analyzes the output specific to the command."""
        pass

    def get_file_path(self) -> str:
        operating_system: OperatingSystem = self.analyzer_options.operating_system
        return os.path.join(self.analyzer_options.output_dir_path, f"{self.get_command().get(operating_system)}.json")

    def analyze_memory_dump(self) -> None:
        """Runs the Volatility analysis using the specific strategy's command."""
        command: str | None = self.get_command().get(self.analyzer_options.operating_system)
        if command:
            print(f"Running analysis for {command}")
            self.run_volatility_command(command)
        else:
            print("No command found for the specified operating system.")

    def run_volatility_command(self, command: str) -> None:
        """
        Executes the Volatility command and saves the result to a JSON file.

        Args:
        - command (str): The Volatility command to execute.
        """
        output_dir: str = self._prepare_output_directory()
        output_file: str = os.path.join(output_dir, f"{command}.json")
        cmdline_command: list[str] = self._build_command(command)

        try:
            self._execute_command(cmdline_command, output_file)
            print(f"Analysis for {command} completed successfully.")
        except subprocess.CalledProcessError as e:
            print(f"Error analyzing memory dump: {e}")
        except Exception as e:
            print(f"Unexpected error: {e}")

    def _prepare_output_directory(self) -> str:
        """Ensure the output directory exists, create it if necessary."""
        output_dir: str = self.analyzer_options.output_dir_path
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)
            print(f"Created directory: {output_dir}")
        return output_dir

    def _build_command(self, command: str) -> list[str]:
        """Construct the full command line to execute Volatility."""
        return [
            'python', self.analyzer_options.volatility3_path,
            '-r', 'json', '-f', self.analyzer_options.input_path, command
        ]

    @staticmethod
    def _execute_command(cmdline_command: list[str], output_file: str) -> None:
        """Execute the command and handle output and errors."""
        with open(output_file, 'w') as f:
            result = subprocess.run(cmdline_command, stdout=f, stderr=subprocess.PIPE, text=True)

        if result.returncode != 0:
            raise subprocess.CalledProcessError(result.returncode, cmdline_command, output=result.stderr)
