import json
from typing import override
from statistics import mean

from malwareAnalysis.malwareAnalysisTool.analysis.AnalysisStrategy import AnalysisStrategy
from malwareAnalysis.malwareAnalysisTool.analysis.models.OperatingSystem import OperatingSystem
from malwareAnalysis.malwareAnalysisTool.analysis.models.data.PsTreeData import PsTreeData
from malwareAnalysis.malwareAnalysisTool.analysis.models.result.PsTreeSummary import PsTreeSummary


class PsTreeStrategy(AnalysisStrategy[PsTreeData, PsTreeSummary]):
    """
    The `pstree` plugin provides a visual representation of the parent-child relationships
    among processes, which is valuable for understanding process execution flows and
    identifying potential malicious behavior.

    Generic parameters:
        - TData: PsTreeData
        - TSummary: PsTreeSummary
    """

    @override
    def get_command(self) -> dict[OperatingSystem, str]:
        return {OperatingSystem.WINDOWS: 'windows.pstree'}

    @override
    def analyze_output(self, file_path: str = None) -> None:
        path_to_use: str = file_path if file_path else self.get_file_path()

        try:
            with open(path_to_use, 'r') as file:
                data: list[dict] = json.load(file)  # Versuch, den Inhalt als JSON zu laden

            self.analyzer_output: list[PsTreeData] = self.parse_process_tree_data(data)
            self.analyzer_summary: PsTreeSummary = self.summarize_process_tree_data()

        except (FileNotFoundError, json.JSONDecodeError) as e:
            print(f"Error: Failed to parse JSON file at {path_to_use}. {e}")
            self.analyzer_output: list[PsTreeData] = []
            self.analyzer_summary: PsTreeSummary = PsTreeSummary(
                nTree=0,
                nHandles=0,
                nPID=0,
                nPPID=0,
                AvgThreads=0.0,
                nWow64=0,
                AvgChildren=0.0
            )

    @staticmethod
    def parse_process_tree_data(data: list[dict]) -> list[PsTreeData]:
        def parse(data_item: dict) -> PsTreeData:
            children: list[PsTreeData] = [parse(child) for child in data_item.get('__children', [])]

            return PsTreeData(
                Audit=data_item.get('Audit'),  # Can be None
                Cmd=data_item.get('Cmd'),  # Can be None
                CreateTime=data_item['CreateTime'],
                ExitTime=data_item.get('ExitTime'),  # Can be None
                Handles=data_item.get('Handles'),  # Can be None
                ImageFileName=data_item['ImageFileName'],
                Offset=data_item['Offset(V)'],
                PID=data_item['PID'],
                PPID=data_item['PPID'],
                Path=data_item.get('Path'),  # Can be None
                SessionId=data_item.get('SessionId'),  # Can be None
                Threads=data_item['Threads'],
                Wow64=data_item['Wow64'],
                children=children
            )

        return [parse(item) for item in data]

    def summarize_process_tree_data(self) -> PsTreeSummary:
        """
        Summarize key metrics for process trees, including all child processes recursively.
        """

        def collect_all_processes(processes: list[PsTreeData]):
            """Recursively collects all processes including children."""
            all_procs = []
            for proc in processes:
                all_procs.append(proc)
                all_procs.extend(collect_all_processes(proc.children))
            return all_procs

        # Flatten the process tree to include all child processes
        all_processes: list[PsTreeData] = collect_all_processes(self.analyzer_output)

        # Total number of processes in the tree
        nTree: int = len(all_processes)

        # Number of unique parent process IDs (PPID)
        nHandles: int = len([proc for proc in all_processes if proc.Handles is not None])

        # Unique process IDs (PID)
        nPID: int = len(set(proc.PID for proc in all_processes))

        # Unique parent process IDs (PPID)
        nPPID: int = len(set(proc.PPID for proc in all_processes if proc.PPID is not None))

        # Average thread count across all processes (check if there are any valid thread counts)
        threads: int = [proc.Threads for proc in all_processes if proc.Threads is not None]
        AvgThreads: float = mean(threads) if threads else 0

        # Number of 64-bit processes
        nWow64: int = sum(1 for proc in all_processes if proc.Wow64)

        # Calculate the average number of children per process
        total_children: int = sum(len(proc.children) for proc in all_processes)
        AvgChildren: float = total_children / nTree if nTree > 0 else 0.0

        return PsTreeSummary(
            nTree=nTree,
            nHandles=nHandles,
            nPID=nPID,
            nPPID=nPPID,
            AvgThreads=AvgThreads,
            nWow64=nWow64,
            AvgChildren=AvgChildren
        )