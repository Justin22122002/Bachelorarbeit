import json
from typing_extensions import override

from malwareAnalysis.malwareAnalysisTool.analysis.AnalysisStrategy import AnalysisStrategy
from malwareAnalysis.malwareAnalysisTool.analysis.models.OperatingSystem import OperatingSystem
from malwareAnalysis.malwareAnalysisTool.analysis.models.data.LdrModulesData import LdrModulesData
from malwareAnalysis.malwareAnalysisTool.analysis.models.result.LdrModulesSummary import LdrModulesSummary


class LdrModulesStrategy(AnalysisStrategy[LdrModulesData, LdrModulesSummary]):
    """
    A strategy for analyzing loaded modules in system memory.

    This strategy operates on `LdrModulesData` and produces a summary of type `LdrModulesSummary`.
    """

    @override
    def get_command(self) -> dict[OperatingSystem, str]:
        """
        Returns the Volatility command required for extracting loaded module information.
        """
        return {OperatingSystem.WINDOWS: 'windows.ldrmodules'}

    @override
    def analyze_output(self, file_path: str | None = None) -> None:
        """
        Parses the output JSON file and extracts loaded module-related data.
        """
        path_to_use: str = file_path if file_path else self.get_file_path()

        try:
            with open(path_to_use, 'r') as file:
                data: list[dict] = json.load(file)

            self.analyzer_output: list[LdrModulesData] = self.parse_ldrmodules_data(data)
            self.analyzer_summary: LdrModulesSummary = self.summarize_ldrmodules_data()

        except json.JSONDecodeError as e:
            print(f"Error: Failed to parse JSON file at {path_to_use}. {e}")
            self.analyzer_output = []
            self.analyzer_summary = LdrModulesSummary(
                nmodules=0,
                avg_modules_per_proc=0.0,
                ldrmodules_not_in_load=0,
                ldrmodules_not_in_init=0,
                ldrmodules_not_in_mem=0,
                ldrmodules_not_in_load_avg=0.0,
                ldrmodules_not_in_init_avg=0.0,
                ldrmodules_not_in_mem_avg=0.0
            )

    @staticmethod
    def parse_ldrmodules_data(data: list[dict]) -> list[LdrModulesData]:
        """
        Parses the JSON output to create a list of LdrModulesData instances.
        """
        def parse(data_item: dict) -> LdrModulesData:
            children: list[LdrModulesData] = [parse(child) for child in data_item.get('__children', [])]

            return LdrModulesData(
                base=data_item.get('Base', 0),
                in_init=data_item.get('InInit', False),
                in_load=data_item.get('InLoad', False),
                in_mem=data_item.get('InMem', False),
                mapped_path=data_item.get('MappedPath', ''),
                pid=data_item.get('Pid', 0),
                process=data_item.get('Process', ''),
                children=children
            )

        return [parse(item) for item in data]

    def summarize_ldrmodules_data(self) -> LdrModulesSummary:
        """
        Summarizes the loaded module data metrics:
        - Total number of loaded modules (nmodules).
        - Average number of modules per process (avg_modules_per_proc).
        - Counts of missing modules to detect anomalies.
        """

        total_modules: int = len(self.analyzer_output)
        unique_processes: int = {module.pid for module in self.analyzer_output}
        total_processes: int = len(unique_processes)

        avg_modules_per_proc = (total_modules / total_processes) if total_processes > 0 else 0.0

        total_not_in_load: int = sum(1 for module in self.analyzer_output if not module.in_load)
        total_not_in_init: int = sum(1 for module in self.analyzer_output if not module.in_init)
        total_not_in_mem: int = sum(1 for module in self.analyzer_output if not module.in_mem)

        avg_not_in_load: float = (total_not_in_load / total_modules) if total_modules > 0 else 0.0     # Avg number of modules missing from load list
        avg_not_in_init: float = (total_not_in_init / total_modules) if total_modules > 0 else 0.0     # Avg number of modules missing from init list
        avg_not_in_mem: float = (total_not_in_mem / total_modules) if total_modules > 0 else 0.0       # Avg number of modules missing from mem list

        # RÃ¼ckgabe einer LdrModulesSummary-Instanz mit berechneten Werten
        return LdrModulesSummary(
            nmodules=total_modules,
            avg_modules_per_proc=avg_modules_per_proc,
            ldrmodules_not_in_load=total_not_in_load,
            ldrmodules_not_in_init=total_not_in_init,
            ldrmodules_not_in_mem=total_not_in_mem,
            ldrmodules_not_in_load_avg=avg_not_in_load,
            ldrmodules_not_in_init_avg=avg_not_in_init,
            ldrmodules_not_in_mem_avg=avg_not_in_mem
        )
