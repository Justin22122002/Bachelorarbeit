import json
from typing_extensions import override
from statistics import mean

from malwareAnalysis.malwareAnalysisTool.analysis.AnalysisStrategy import AnalysisStrategy
from malwareAnalysis.malwareAnalysisTool.analysis.models.OperatingSystem import OperatingSystem
from malwareAnalysis.malwareAnalysisTool.analysis.models.data.DllListData import DllListData
from malwareAnalysis.malwareAnalysisTool.analysis.models.result.DllListSummary import DllListSummary


class DllListStrategy(AnalysisStrategy[DllListData, DllListSummary]):
    """
    A strategy for analyzing the list of loaded DLLs in system memory.

    This strategy operates on `DllListData` and produces a summary of type `DllListSummary`.
    """

    @override
    def get_command(self) -> dict[OperatingSystem, str]:
        """
        Returns the Volatility command required for extracting DLL list information.
        """
        return {OperatingSystem.WINDOWS: 'windows.dlllist'}

    @override
    def analyze_output(self, file_path: str | None = None) -> None:
        """
        Parses the output JSON file and extracts DLL list data.
        """
        path_to_use: str = file_path if file_path else self.get_file_path()

        try:
            with open(path_to_use, 'r') as file:
                data: list[dict] = json.load(file)

            self.analyzer_output: list[DllListData] = self.parse_dll_list_data(data)
            self.analyzer_summary: DllListSummary = self.summarize_dll_list_data()

        except json.JSONDecodeError as e:
            print(f"Error: Failed to parse JSON file at {path_to_use}. {e}")
            self.analyzer_output = []
            self.analyzer_summary = DllListSummary(
                ndlls=0,
                avg_dlls_per_proc=0.0,
                avg_handles=0.0
            )

    @staticmethod
    def parse_dll_list_data(data: list[dict]) -> list[DllListData]:
        """
        Parses the JSON output to create a list of DllListData instances.
        """
        def parse(data_item: dict) -> DllListData:
            children: list[DllListData] = [parse(child) for child in data_item.get('__children', [])]

            return DllListData(
                Name=data_item['Name'],
                Base=data_item['Base'],
                PID=data_item['PID'],
                Path=data_item['Path'],
                Size=data_item['Size'],
                LoadTime=data_item.get('LoadTime'),
                FileOutput=data_item.get('File output', 'Disabled'),
                children=children
            )

        return [parse(item) for item in data]

    def summarize_dll_list_data(self) -> DllListSummary:
        """
        Summarizes the loaded DLL data metrics:
        - Total number of loaded DLLs (ndlls).
        - Average number of DLLs per process (avg_dlls_per_proc).
        - Average handles (avg_handles) - this metric is calculated but not used in further analysis.
        """
        total_dlls: int = len(self.analyzer_output)

        if total_dlls == 0:
            return DllListSummary(ndlls=0, avg_dlls_per_proc=0.0, avg_handles=0.0)

        dlls_per_process: dict[int, list[DllListData]] = {}
        for dll in self.analyzer_output:
            dlls_per_process.setdefault(dll.PID, []).append(dll)

        avg_dlls_per_proc: float = mean(len(dlls) for dlls in dlls_per_process.values())
        avg_handles: float = mean(dll.Size for dll in self.analyzer_output if dll.Size is not None)

        return DllListSummary(
            ndlls=total_dlls,
            avg_dlls_per_proc=avg_dlls_per_proc,
            avg_handles=avg_handles
        )
